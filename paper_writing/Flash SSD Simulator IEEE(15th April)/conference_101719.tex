\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{pythonhighlight}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Eyana: The SSD Simulator\\
{\footnotesize \textsuperscript{*}Explore the inner workings of Solid-State Drives}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Habibur Rahman}
\IEEEauthorblockA{\textit{dept. AI Convergence Engineering} \\
\textit{Gyeongsang National University}\\
Jinju, South Korea \\
habib@gnu.ac.kr}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Prof Jaeho Kim}
\IEEEauthorblockA{\textit{dept. AI Convergence Engineering} \\
\textit{Gyeongsang National University}\\
Jinju, South Korea \\
jaeho.kim@gnu.ac.kr}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Omar Faroque}
\IEEEauthorblockA{\textit{dept. Software Development Engineer} \\
\textit{Amazon Web Services}\\
City, Country \\
faroque.ae@gmail.com}
}

\maketitle

\begin{abstract}
Solid-state drives (SSDs) are widely used in various computer systems today, from datacenters to enterprise servers. As these systems demand more and more input/output (I/O) operations, SSD manufacturers are updating their designs to meet these needs.  Existing simulators usually focus on internal operations and can be difficult to install. Also, simulating a whole system with traditional SSD models often takes a long time and requires a lot of computing power. This paper presents an innovative web based educational and research tool, the NAND flash memory cell (called floating gate transistor) and flash-based solid-state-drive (SSD) simulator, created to facilitate a comprehensive understanding of SSDs by providing learners or researchers  with a visual representation of the internal workings of SSDs and transistors NAND cells.

Our simulator allows learners and researchers to upload trace files, enabling visualization of various allocation methods and comparisons between different trace files. These comparisons include metrics such as write count, wear leveling, read count, erase count, and more. While existing simulators exist, they often pose challenges for beginner users due to their complexity and steep learning curve.

Our research highlights the profound impact of this simulator on understanding SSD technology. It significantly reduces learning time and enhances comprehension among students. By providing immersive visualization of NAND flash memory cells, including single-level cell (SLC), multi-level cell (MLC), and triple-level cell (TLC) structures, our simulator demystifies data storage and management within SSDs.

The paper delves into SSD architecture and organization, covering pages, blocks, the flash translation layer (FTL), logical block mapping, wear leveling, and over-provisioning. This provides an in-depth understanding of these fundamental components. Crucial SSD functionalities such as read, write, and erase operations, garbage collection, and TRIM are clarified, along with their roles in maintaining SSD performance.

Furthermore, the research explores advanced functionalities, parallelism strategies, and allocation methods (dynamic and static allocation). Our simulators extend data placement policies such as Multi-streamed, Zoned Namespaces, and Flexible Data Placement. Feedback from a survey involving over a thousand students and researchers validates the simulator’s effectiveness in improving SSD comprehension and learning speed.

This paper also outlines potential applications in industry settings, emphasizing the simulator’s utility for professionals and students alike. Our innovative simulator not only enhances SSD understanding but also contributes to the pedagogical landscape by visualizing the complexities of SSDs, streamlining the learning process, and fostering a robust foundation in computer architecture and storage technologies.

\end{abstract}

\begin{IEEEkeywords}
Flash SSD, Simulator, Eyana, Web-based, Write Amplification, Wear Leveling, Garbage Collection, Flash Translation Layer, Parallelism, Multi-Channel
\end{IEEEkeywords}


\section{Related Work}
In the realm of SSD simulation, numerous tools have emerged to aid both students and researchers in comprehending the complexities of SSD design and operation. MQSim[citation][ ] offers an extensive feature set but may present challenges or take some time in installation and understanding  inner workings  due to its Linux environment and virtual box setup requirements. FlashSIM[citation] provides versatile simulation capabilities catering to educational and research needs, while SSDModel[citation], though rudimentary, contributes to the simulation landscape. Meanwhile, SSDSim[citation] and other traditional simulators often demand significant study time for installation and understanding. NANDFlashSim[citation], VSSIM[citation], WiscSim[citation], and SimpleSSD[citation] offer varying functionality and installation complexities, reflecting the diverse array of available SSD simulators. However, our proposed simulator, EyanaSSD,  distinguishes itself by prioritizing educational and research-oriented design, offering a user-friendly web-based installation process, intuitive visualization tools, and comprehensive documentation. EyanaSSD further enhances accessibility and interactivity through on-demand web access and real-time monitoring, underscoring its value as an educational resource and research tool in the SSD simulation domain.

\section{Eyana: The SSD Simulator}
Figure  illustrates a high-level overview of Eyana: The SSD Simulator. Our simulator manages incoming I/O requests through several layers. Initially, a request is received either from the Host Input Layer or by uploading a trace file, and the corresponding targeted address is translated by the Flash Translation Layer (FTL).

Next, the Allocation Scheme Layer takes the host-selected allocation scheme and processes the request, abstracting the physical layout of interconnection buses and flash dies. Upon completion of the I/O request, the Allocation Scheme Layer reports back to the host-side controller. Additionally, it monitors the amount of data written into the SSD and signals the controller to execute garbage collection as needed.

Users can also trigger TRIM operations by clicking on the TRIM button from the host side. This functionality allows for efficient management of unused data blocks within the SSD.

\subsection{Floating Gate Transistors - The Heart of SSDs}
In today’s increasingly mobile world, the demand for greater computational capacity is at an all-time high, with an expectation for it to be accessible anytime and anywhere. Deep neural networks (DNNs), consisting of convolution and fully connected layers, are driving significant advancements in artificial intelligence[1], particularly in areas such as image recognition[2,3], speech recognition[4,5], natural language processing[6], and even strategic games like Go[7,8]. As the sizes of these DNNs continue to grow exponentially[9], there's a pressing need for computing devices with enhanced capabilities. To meet these demands, researchers have developed specialized integrated circuits like the DianNao family[10], tensor processing units[11], PASCAL graph processing units (GPUs)[12], and Eyeriss, aimed at accelerating computing speed and reducing power consumption. However, despite these advancements, there is a lack of web-based simulators according to our research. In response, our simulator offers a comprehensive visualization of major functionalities:

\subsubsection{Write[cite]}: The process of storing data in an SSD by applying a high voltage to the control gate, allowing electrons to tunnel through the silicon insulator and become trapped in the floating gate, representing data storage.Fig

\subsubsection{Read[cite]}: Retrieving stored data from an SSD by applying a low voltage to the control gate and interpreting the presence or absence of current flow from source to drain, indicating the stored data as either "0" or "1".Fig
\subsubsection{Erase[cite]}: The act of removing trapped electrons from the floating gate of an SSD cell, resetting its state to prepare it for new data storage.Fig
\subsubsection{Single Level Cell (SLC)[cite]}: SSD technology that stores one bit of data per cell, known for its fast read and write speeds, along with high endurance and reliability.
\subsubsection{Multi Level Cell (MLC)[cite]}: SSD technology that stores two bits of data per cell, utilizing voltage ranges to represent different data states, offering higher storage density but potentially slower performance and lower endurance compared to SLC.Fig
\subsubsection{Triple Level Cell (TLC)[cite]}: SSD technology that stores three bits of data per cell, utilizing multiple voltage ranges for data representation, providing even higher storage density but potentially lower endurance and slightly slower performance compared to SLC and MLC. Fig

\subsection{Organization of an SSD}
In our SSD simulator, we have utilized Single Level Cell (SLC) transistors to create pages. Each page in our simulator can store 4 KB of data, and to achieve this capacity, we have employed approximately 32,768 floating gate transistors for each page.

The organization of our SSD simulator is structured as follows: Four pages are combined to form one block, and four blocks are further grouped to create one plane. Two planes are then integrated to form a die, and two dies are packaged together, resulting in one channel.

\begin{table}[htbp]
    \centering
    \caption{NAND Flash Device Specifications}
    \begin{tabular}{l c}
        Specification & Value \\
        Cell Type & Single Level Cell (SLC) \\
        Bit per Cell & 1 bit \\
        Page Size & 4 KB \\
        Block Size & 16 KB (4 pages) \\
        Page Read Time & 25 microseconds ($\mu$s) \\
        Page Program (Write) Time & 200 microseconds ($\mu$s) \\
        Block Erase Time & 1.5 milliseconds (ms) \\
    \end{tabular}
\end{table}
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=5cm]{architecture_of_ssd_simulation.png}
    \caption{Internal Structure of Flash Memory}
    \label{fig:architecture_of_ssd_simulation}
\end{figure}

The user initiates commands through the host interface, with Serial ATA (SATA) and PCI Express (PCIe) being the most common interfaces for newly released SSDs. The SSD controller's processor receives these commands and then transfers them to the flash controller. Additionally, SSDs are equipped with embedded RAM memory, primarily used for caching data and storing mapping information.

Our SSD simulator's architecture, as illustrated in Figure 3, provides an efficient and reliable platform for evaluating the performance of NAND Flash devices in various scenarios. Figure 4 depicts the overall SSD architecture, illustrating how commands flow from the host interface to the flash controller, along with the presence of embedded RAM for caching and mapping data.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=5cm]{ssd_architecture.png}
    \caption{Architecture of a Solid State Drive}
    \label{fig:ssd_architecture}
\end{figure}

\section{Eyana: The SSD Simulator}
Eyana: The SSD Simulator describes the internal architecture of an SSD and visualizes the processes of Write, Read, Update, Garbage Collection, and Parallel Writing. Being a web-based simulator, anyone can access and use it to understand the core concepts of an SSD.

\subsection{Write}
When data is written to an SSD, the process involves creating a logical address that contains information about the uploaded files or programs requiring storage. This logical address is then mapped to a corresponding physical address, which specifies the specific physical page and block where the data is stored. The mapping table holds the information that facilitates this logical-to-physical address translation.
Throughout the write process, data is written in increments of the page size. As a result, even if a write operation only modifies a single byte, an entire page is written. This phenomenon, where more data is written than actually required, is known as write amplification.
\subsection{Making Data Storage Smarter: Insights from the Eyana SSD Simulator}
When we save stuff on a computer, we have to be smart about how we do it. Imagine the computer's storage as a big grid where we put our things. If we don't put things in the right places, we might use up more space than we actually need. This is what we call "write amplification."

Even if we're just putting a tiny bit of information, it can sometimes take up way more space than it should. Think about writing a short message on a huge sheet of paper – that's like using a lot of paper for a tiny message. In certain situations, even if you're just writing a single letter, it could end up using a whole big page, which is like using 16 pieces of paper. That's not very smart!

But there's more to the story. When we don't put our information in the right spots, the computer has to do extra work. It has to read the place where we want to add something, make changes, and then put it back. This extra work slows things down. Imagine you want to fix a sentence in a book, but instead of fixing only that sentence, you have to read the entire page, fix the sentence, and then put the page back. This extra step takes more time.

To work better, we have some simple rules to remember when putting our information:

\subsubsection{Write Enough} 
Avoid putting really tiny bits of information. It's better to write a bit more, like a whole sentence, so the computer can do its job faster. Usually, it's a good idea to write at least as much as you could fit on a book page, which is like 16 pieces of paper.

\subsubsection{Put Things in the Right Spots} 
When you write, make sure to put your stuff in the right places. It's like solving a puzzle – things fit better and work faster when they're in the correct spots.

\subsubsection{Group Small Stuff Together} 
Instead of writing lots of small things one after the other, it's smarter to gather them up first and then write them all together. It's a bit like putting all your small notes in one envelope before sending them, instead of sending each note separately.

By following these easy rules, the computer can work faster and use space more efficiently. It's like organizing your things neatly so everything runs smoothly.

And here's the cool part: we've put all these ideas into action in our online simulator, Eyana. You can see how it all works visually. This way, we're showing how these simple rules can make a big difference in how we use computers.

\subsection{Read}
The SSD read process involves receiving a logical address request, mapping it to a corresponding physical address using a mapping table, retrieving the data from the specified physical page and block in the NAND flash memory, and transferring the data to the requesting application or operating system.
\subsection{Update}
NAND-flash memory operates with a specific constraint: a page can be written to only if it is in the "free" state. When data needs to be changed or updated, the process involves a series of steps known as "read-modify-write." First, the content of the target page is copied into an internal register. Then, the required modifications are made to the data, and the updated version is stored in a different "free" page.
This "read-modify-write" operation occurs because the data cannot be updated in-place within the original page. Consequently, the "free" page, which is a separate and available page, is used to store the updated data. Once the new data has been successfully persisted to the drive, the original page is marked as "stale," indicating that it contains outdated information. The stale page remains in this state until it is eventually erased, and its space becomes available to be used for future write operations.
The "read-modify-write" process and the write amplification phenomenon described earlier are factors that affect the performance and lifespan of SSDs. Careful management of write operations and garbage collection techniques are employed to optimize SSD performance and ensure its long-term reliability.
\subsection{Garbage Collection}
Garbage collection erases outdated data in SSDs, ensuring efficient write processing. Our simulator traces stale data, which can be deleted manually or after a set time. This optimizes SSD performance and maximizes usable capacity.
\subsection{Allocation Schemes}
An allocation scheme dictates the process of selecting an available physical page to store a logical page on an SSD. To pinpoint a specific physical page, one must possess knowledge of the channel address, chip address, along with the die, plane, block, and page addresses, as illustrated in ``Fig.~\ref{fig:ssd_architecture}''. The comprehensive SSD address format is depicted in ``Fig.~\ref{fig:architecture_of_ssd_simulation}''.

Allocation schemes fall into two primary categories: static and dynamic.
\subsubsection{Static Allocation}
Static allocation involves initially assigning a logical page to a predetermined channel, chip, die, and plane before proceeding to allocate it to any available free physical pages within the plane. The allocation of channel, chip, die, and plane addresses to each logical page usually follows specific predetermined formulas, which define a particular allocation scheme.

``Fig.~\ref{fig:static_allocation}'' depicts six distinct static allocation schemes denoted as S1, S2, S3, S4, S5, and S6. As elaborated, each of these special static allocation schemes calculates channel, chip, die, and plane addresses for every logical page using specific formulas. In the subsequent discussion, we outline these formulas for each static allocation scheme. The relevant variables and operators required for these formulas are outlined in ``Table.~\ref{table:variables_explanation}''.

\begin{table}[htbp]
    \centering
    \caption{The Variables and Operators Used in the Formulas of Assigning Physical Addresses of Logical Pages in Static Allocation Schemes}
    \label{table:variables_explanation}
    \begin{tabular}{|l|p{0.7\linewidth}|}
        \hline
        \textbf{Variable} & \textbf{Explanation} \\
        \hline
        while\_loop\_tracer & Logical page number  \\
        \hline
        n\_channel & Represents a calculation or value (not specified) \\
        \hline
        n\_chip & The number of chips in a channel \\
        \hline
        n\_die & The number of dies in a chip \\
        \hline
        n\_plane & The number of planes in a die \\
        \hline
        / & Division of two values followed by rounding down \\
        \hline
        \% & Modulo arithmetic \\
        \hline
        X & Multiplication \\
        \hline
    \end{tabular}
\end{table}

S1: As shown in ``Fig.~\ref{fig:static_allocation}a'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the chip-level parallelism;
    \item the die-level parallelism;
    \item the plane-level parallelism; and
    \item the channel-level parallelism.
\end{enumerate}
The python implementation of formula S1 are:
\begin{python}
channel = Math.floor(while_loop_tracer / 
        (n_plane * n_die * n_chip)) % n_channel
chip = while_loop_tracer % n_chip
die = Math.floor(while_loop_tracer / 
        n_chip) % n_die
plane = Math.floor(while_loop_tracer / 
        (n_die * n_chip)) % n_plane
\end{python}

S2: As shown in ``Fig.~\ref{fig:static_allocation}b'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the channel-level parallelism;
    \item the chip-level parallelism;
    \item the die-level parallelism; and
    \item the plane-level parallelism.
\end{enumerate}
The python implementation of formula S2 are:
\begin{python}
channel = while_loop_tracer % n_channel
chip = Math.floor(while_loop_tracer 
        / n_channel) % n_chip
die = Math.floor(while_loop_tracer 
        / (n_chip * n_channel)) % n_die
plane = Math.floor(while_loop_tracer 
        / (n_die * n_chip * n_channel)) % n_plane
\end{python}

S3: As shown in ``Fig.~\ref{fig:static_allocation}c'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the channel-level parallelism;
    \item the plane-level parallelism;
    \item the chip-level parallelism; and
    \item the die-level parallelism
\end{enumerate}
The python implementation of formula S3 are:
\begin{python}
channel = while_loop_tracer % n_channel
chip = Math.floor(while_loop_tracer / 
        (n_plane * n_channel)) % n_chip
die = Math.floor(while_loop_tracer / 
        (n_plane * n_chip * n_channel)) % n_die
plane = Math.floor(while_loop_tracer / 
        n_channel) % n_plane
\end{python}

S4: As shown in ``Fig.~\ref{fig:static_allocation}d'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the channel-level parallelism;
    \item the die-level parallelism;
    \item the chip-level parallelism; and
    \item the plane-level parallelism
\end{enumerate}
The python implementation of formula S4 are:
\begin{python}
channel = while_loop_tracer % n_channel
chip = Math.floor(while_loop_tracer / 
        (n_die * n_channel)) % n_chip
var die = Math.floor(while_loop_tracer / 
        n_channel) % n_die
var plane = Math.floor(while_loop_tracer / 
        (n_die * n_chip * n_channel)) % n_plane
\end{python}

S5: As shown in ``Fig.~\ref{fig:static_allocation}e'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the channel-level parallelism;
    \item the plane-level parallelism;
    \item the die-level parallelism; and
    \item the chip-level parallelism
\end{enumerate}
The python implementation of formula S5 are:
\begin{python}
channel = while_loop_tracer % n_channel
chip = Math.floor(while_loop_tracer / 
        (n_plane * n_die * n_channel)) % n_chip
die = Math.floor(while_loop_tracer / 
        (n_plane * n_channel)) % n_die
plane = Math.floor(while_loop_tracer / 
        n_channel) % n_plane
\end{python}

S6: As shown in ``Fig.~\ref{fig:static_allocation}f'', the priority order of parallelism levels in this scheme is: \begin{enumerate}
    \item the channel-level parallelism;
    \item the die-level parallelism;
    \item the plane-level parallelism; and
    \item the chip-level parallelism
\end{enumerate}
The python implementation of formula S5 are:
\begin{python}
channel = while_loop_tracer % n_channel
chip = Math.floor(while_loop_tracer / 
        (n_plane * n_die * n_channel)) % n_chip
die = Math.floor(while_loop_tracer / 
        n_channel) % n_die
plane = Math.floor(while_loop_tracer / 
        (n_die * n_channel)) % n_plane
\end{python}

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=10.5cm]{static_allocation.jpg}
    \caption{The six typical static allocation schemes}
    \label{fig:static_allocation}
\end{figure}
\subsubsection{Dynamic Allocation}
Dynamic allocation used in this section assigns a logical page on any idle chip of any idle channel of the entire SSD. The optimal order of parallelism levels used in this dynamic allocation scheme. All the data to read are stored evenly among all the chips of all the channels in the entire SSD. 

For dynamic allocation we used Channel, Chip, Die, and Plane Level Parallelism. 
\begin{enumerate}
    \item Channel-level Parallelism : Channel-level parallelism involves assigning a logical page to any available block on any free channel within the SSD, enabling concurrent operations across multiple channels simultaneously.
    \item Chip-level Parallelism : Chip-level parallelism involves assigning a logical page to any available block on any free chip within the SSD, enabling concurrent operations across multiple chips simultaneously.
    \item Die-level Parallelism : Die-level parallelism involves assigning a logical page to any available block on any free die within the SSD, enabling concurrent operations across multiple dies simultaneously.
    \item Plane-level Parallelism : Plane-level parallelism involves assigning a logical page to any available block on any free plane within the SSD, enabling concurrent operations across multiple planes simultaneously.
\end{enumerate}

\section{Methodology of Survey}
A survey was conducted to gather feedback from students and professionals in the field of computer engineering and semiconductor technology. A total of 238 participants were randomly selected to use our SSD and floating gate transistor simulators and provide feedback. The survey comprised a combination of multiple-choice questions and open-ended responses to gauge participant satisfaction, understanding, and overall impressions of the simulators.

\section{Survey Results}
\subsection{Overall Satisfaction with the SSD Simulator}
In this section, we present the results of the evaluation of user satisfaction with the SSD (Solid State Drive) simulator based on two graphical representations: a pie chart depicting the participants' satisfaction levels and a bar chart showcasing their likelihood of recommending the SSD and Floating Gate Transistor Simulators to others.
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=3.5cm]{rate_setisfation.jpeg}
    \caption{User Satisfaction with the SSD Simulator}
    \label{fig:enter-label}
\end{figure}
The pie chart illustrates the responses of 238 participants regarding their satisfaction with the SSD simulator. The participants were asked to rate their satisfaction on a five-point scale, ranging from "Very Satisfied" to "Very Dissatisfied." The distribution of responses is as follows:
\begin{itemize}
    \item Very Satisfied: 77.7\%
    \item Satisfied: 20.6\%
    \item Neutral: 1.3\%
    \item Dissatisfied: 0\%
    \item Very Dissatisfied: 0.4\%
\end{itemize}
The pie chart clearly indicates that the majority of participants, approximately 77.7\%, expressed being "Very Satisfied" with the SSD simulator. This substantial percentage signifies that a significant proportion of users found the simulator to be highly effective, exceeding their expectations and leading to a positive overall user experience.

Moreover, around 20.6\% of participants rated their satisfaction as "Satisfied," indicating a generally positive perception of the simulator's performance and usability. The minimal percentage of respondents in the "Neutral," "Dissatisfied," and "Very Dissatisfied" categories further reinforces the simulator's success in achieving high user satisfaction, as these categories received very low or no responses.
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=3.6cm]{recommend_to_user.jpeg}
    \caption{Likelihood of Recommending the Simulators}
    \label{fig:enter-label}
\end{figure}
The bar chart presents the responses of participants to the question of how likely they are to recommend the SSD and Floating Gate Transistor Simulators to others. The respondents were provided with a five-point scale, ranging from "Not likely to recommend" (1) to "Very likely to recommend" (5). The distribution of responses is as follows:
\begin{itemize}
    \item 1: (Not likely to recommend): 0\%
    \item 2: 0\%
    \item 3: 3.4\%
    \item 4: 35.4\%
    \item 5 (Very likely to recommend): 61.2\%
\end{itemize}
The bar chart clearly shows an overwhelmingly positive response, with approximately 61.2\% of participants expressing being "Very likely to recommend" the SSD and Floating Gate Transistor Simulators to others. Furthermore, a significant 35.4\% indicated a likelihood of recommending, resulting in an overall high percentage of participants who would endorse the simulators to their peers and colleagues.

These graphical representations of user satisfaction and the likelihood of recommending the simulators corroborate that the SSD simulator has achieved excellent user satisfaction levels. The substantial majority of "Very Satisfied" responses in the pie chart and the high percentages of participants likely to recommend the simulators in the bar chart provide strong evidence of the simulator's effectiveness and positive impact on the user experience.

As we continue to improve and refine the simulator based on valuable user feedback, these results serve as a testament to its success and value as an essential tool for SSD exploration and learning.

\subsection{Understandability of Flash SSD Concept}
In this section, we present the evaluation of the understandability of the Flash SSD (Solid State Drive) concept among users while using the simulator. The primary objective of the simulator was to facilitate users' exploration of the functionalities and performance aspects of Flash SSDs.

A total of participants took part in the evaluation, and they were asked to rate how easy it was for them to comprehend the concept of Flash SSD while using the simulator. The responses were categorized into five levels of understanding: "Very Easy," "Somewhat Easy," "Neutral," "Somewhat Difficult," and "Very Difficult."

The evaluation resulted in the following distribution of responses, depicted in the pie chart:
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=3.6cm]{how_easy.jpeg}
    \caption{Understandability of Flash SSD Concept}
    \label{fig:enter-label}
\end{figure}
The pie chart reveals a highly positive perception among the participants regarding the understandability of the Flash SSD concept:
\begin{itemize}
    \item Very Easy: 80.3\%
    \item Somewhat Easy: 17.6\%
    \item Neutral: 2.1\%
    \item Somewhat Difficult: 0\%
    \item Very Difficult: 0\%
\end{itemize}
The significant majority of respondents, approximately 80.3\%, found it "Very Easy" to grasp the concept of Flash SSD while utilizing the simulator. This substantial percentage suggests that the simulator effectively conveyed the essential aspects of Flash SSD technology in a clear and understandable manner.

Additionally, around 17.6\% of participants rated their understanding as "Somewhat Easy," indicating that they encountered minor difficulties but still found the concept comprehensible overall.

A very small percentage of respondents, approximately 2.1\%, indicated a "Neutral" stance, suggesting that they neither found the concept easy nor difficult to understand. This finding may indicate that these participants might benefit from supplementary resources or additional explanations to enhance their comprehension of the Flash SSD concept.

Notably, no participants expressed that the concept was "Somewhat Difficult" or "Very Difficult" to understand. This outcome is encouraging, signifying that the simulator effectively conveyed the information without causing significant confusion or challenges.

In conclusion, the evaluation of the understandability of the Flash SSD concept using the simulator yielded positive outcomes, with the majority of users finding the concept easy to comprehend. The pie chart visually illustrates the distribution of responses, highlighting the effectiveness of the simulator in conveying the complexities of Flash SSD technology. It is essential to consider the feedback from participants who rated their understanding as "Somewhat Easy" or "Neutral" to further enhance the clarity and educational value of the simulator. By addressing any potential areas of confusion, we can ensure that the simulator continues to serve as an accessible and informative tool for users seeking to enhance their understanding of Flash SSD technology.
\subsection{Time Saved in Understanding SSD and Floating Gate Transistors}
In this section, we analyze the amount of time saved by participants in understanding SSD and Floating Gate Transistors concepts compared to traditional learning methods. The primary objective of the SSD and Floating Gate Transistor Simulators was to provide a more efficient and effective learning experience for users.

A total of participants took part in the evaluation, and they were asked to estimate the time saved using the simulators in four categories: "Significantly saved time (more than 50\%)," "Moderately saved time (around 25\%-50\%)," "Slightly saved time (less than 25\%)," and "No significant time saved." Additionally, there was an option for participants to choose "Not sure" if they were uncertain about the time saved.

The results are summarized in the pie chart below:
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=3.6cm]{save_time.jpeg}
    \caption{Time Saved in Understanding SSD and Floating Gate Transistors}
    \label{fig:enter-label}
\end{figure}
The pie chart illustrates the distribution of responses regarding the time saved by using the simulators compared to traditional learning methods:
\begin{itemize}
    \item Significantly saved time (more than 50%): 72.5%
    \item Moderately saved time (around 25%-50%): 24.2%
    \item Slightly saved time (less than 25%): 3.3%
    \item No significant time saved: 0%
    \item Not sure: 0%
\end{itemize}
The majority of respondents, approximately 72.5\%, reported that the simulators significantly saved them more than 50\% of the time in understanding SSD and Floating Gate Transistors concepts. This high percentage indicates that the simulators proved to be a highly efficient and time-saving tool, accelerating the learning process for most participants.

Around 24.2\% of participants reported a moderate time-saving effect of approximately 25\%-50\%. This suggests that these users experienced notable benefits from using the simulators, although the time saved might not have been as substantial as in the previous category.

A smaller percentage of respondents, approximately 3.3\%, indicated a slight time-saving effect, less than 25\%. Although the proportion is relatively small, it still indicates that the simulators provided some time-saving benefits for a portion of the participants.

Notably, no participants reported "No significant time saved," indicating that the simulators had a positive impact on understanding the concepts compared to traditional learning methods.

Furthermore, no participants selected "Not sure," suggesting that the majority of users were confident in their estimation of the time saved.

In conclusion, the pie chart illustrates the positive impact of the SSD and Floating Gate Transistor Simulators on time-saving in understanding the respective concepts. The majority of participants experienced significant time savings, indicating the effectiveness and efficiency of the simulators in enhancing the learning experience. These results affirm the value of using simulators as a powerful educational tool to streamline the understanding of complex concepts like SSD and Floating Gate Transistors.
\subsection{Rating of the Simulator}
In this section, we present the participants' ratings of the simulator on a scale of 1 to 10. The ratings were obtained to assess the overall effectiveness and satisfaction level of the simulator.

Participants were asked to rate the simulator using the following scale:

1 to 10: (Percentage of participants)
The ratings received from the participants are summarized in the bar chart below:
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth, height=3.6cm]{rate_simulator.jpeg}
    \caption{Rating of the Simulator}
    \label{fig:enter-label}
\end{figure}
The bar chart displays the distribution of ratings as follows:
\begin{itemize}
    \item 1 to 4: 0\%
    \item 5: 0.4\%
    \item 6: 1.7\%
    \item 7: 7.6\%
    \item 8: 21.2\%
    \item 9: 31.4\%
    \item 10: 37.7\%
\end{itemize}
The bar chart reveals that the simulator received predominantly positive ratings. A significant number of participants, approximately 37.7\%, rated the simulator a perfect score of 10, indicating a high level of satisfaction with its performance.

Additionally, approximately 31.4\% of participants gave a rating of 9, showing further positive feedback and strong satisfaction with the simulator.

The ratings from 8 (21.2\%) and 7 (7.6\%) suggest that a considerable portion of users found the simulator above average and satisfactory in meeting their expectations.

Few participants provided ratings of 5 (0.4\%) and 6 (1.7\%), indicating minor room for improvement or a relatively neutral stance towards the simulator.

Notably, no participants provided ratings below 5 (1 to 4), indicating overall satisfaction and a lack of significant dissatisfaction with the simulator.

In conclusion, the bar chart visually represents the participants' ratings of the simulator on a scale of 1 to 10. The majority of users expressed high levels of satisfaction, with a significant portion giving the simulator a perfect rating of 10. These positive ratings reflect the simulator's effectiveness in meeting its objectives and the overall satisfaction of the users with its performance and usability.


\section{Discussion}
The development of Eyana: The SSD Simulator stemmed from the recognition of the challenges students face when trying to understand the complex concepts of Flash SSD technology. As outlined in the introduction, the lack of easily accessible and comprehensive web-based simulators prompted us to create an innovative and user-friendly tool that would facilitate the comprehension of Flash SSDs.

Eyana was designed with the primary objective of simplifying the understanding of Flash SSD technology. Through visual demonstrations of critical operations such as Page, Block, Write, Read, Update, Delete, garbage collection, and the flash translation layer, Eyana provides a clear representation of how transistors come together to form pages, and how pages combine to create blocks, ultimately composing an SSD. The visual representation, accompanied by comprehensive documentation, clarifies concepts like Write Amplification, Wear Leveling, Parallelism, and Multi-Channel, shedding light on the complexities of Flash SSD technology.

One of the key strengths of Eyana is its ability to offer valuable insights into the functioning of Flash SSDs. By illustrating the selection of pages and blocks during various operations, students gain a deeper understanding of the intricate processes involved in writing, reading, updating, and deleting data. The simulator also presents the workings of the garbage collection process, an essential aspect of Flash SSD technology that contributes to overall comprehension.

The real-time simulation feature of Eyana, allowing users to upload files and observe operations as they occur, plays a pivotal role in enhancing the learning experience. By providing students with the opportunity to interact with the simulator and witness the entire procedure in action, Eyana accelerates the learning process, enabling users to grasp the concepts efficiently within a short timeframe.

To assess the effectiveness of Eyana in enhancing the understanding of Flash SSDs, a survey was conducted among users. The results of the survey were overwhelmingly positive, with an impressive 99\% of the users finding the simulator highly effective and rating it among the best available resources for comprehending Flash SSD technology. These findings further validate the impact and value of Eyana as an educational tool for students and researchers interested in Flash SSD technology.

\section{ conclusion }
In conclusion, Eyana: The SSD Simulator is an innovative and user-friendly web-based tool that successfully simplifies the comprehension of Flash SSD technology. Through visual demonstrations, real-time simulations, and comprehensive documentation, Eyana empowers users to gain valuable insights into the intricate workings of Flash SSDs. The overwhelmingly positive response from users in the survey highlights the simulator's efficacy in facilitating the understanding of Flash SSD concepts. By contributing to the pool of educational resources, Eyana proves to be a valuable asset for students and researchers seeking to explore the world of Flash SSD technology. Moving forward, continuous improvements and updates to Eyana will further enhance its educational value and ensure that it remains a cutting-edge resource for learners and enthusiasts alike.

\section*{References}

Please number citations consecutively within brackets \cite{b1}. The 
sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference 
number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at 
the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''

Number footnotes separately in superscripts. Place the actual footnote at 
the bottom of the column in which it was cited. Do not put footnotes in the 
abstract or reference list. Use letters for table footnotes.

Unless there are six authors or more give all authors' names; do not use 
``et al.''. Papers that have not been published, even if they have been 
submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers 
that have been accepted for publication should be cited as ``in press'' \cite{b5}. 
Capitalize only the first word in a paper title, except for proper nouns and 
element symbols.

For papers published in translation journals, please give the English 
citation first, followed by the original foreign-language citation \cite{b6}.

\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
\bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
\bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
\bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
\bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
\bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
